%%-*- mode: erlang -*
%% ex: ft=erlang

%% @doc listener.max_connections is an integer or 'infinity' defining 
%% the number of concurrent connections. This option can be overridden
%% by either specifying on the protocol level:
%%
%%     - listener.tcp.max_connections
%%     - listener.ssl.max_connections
%%     - listener.websocket.max_connections 
%%
%% or on the listener level:
%%
%%     - listener.tcp.my_tcp_listener.max_connections
%%     - listener.ssl.my_ssl_listener.max_connections
%%     - listener.websocket.my_websocket_listener.max_connections
{mapping, "listener.max_connections", "emqttd_server.listeners", [
                                                                  {default, {{max_connections}} },
                                                                  {datatype, [integer, {atom, infinity}]}
                                                                 ]}. 
{mapping, "listener.tcp.max_connections", "emqttd_server.listeners", [
                                                                  {default, {{max_connections}} },
                                                                  {commented, {{max_connections}} },
                                                                  {datatype, [integer, {atom, infinity}]},
                                                                  hidden
                                                                 ]}. 

{mapping, "listener.tcp.$name.max_connections", "emqttd_server.listeners", [
                                                                  {default, {{max_connections}} },
                                                                  {commented, {{max_connections}} },
                                                                  {datatype, [integer, {atom, infinity}]},
                                                                  hidden
                                                                 ]}. 

{mapping, "listener.ssl.max_connections", "emqttd_server.listeners", [
                                                                  {default, {{max_connections}} },
                                                                  {commented, {{max_connections}} },
                                                                  {datatype, [integer, {atom, infinity}]},
                                                                  hidden
                                                                 ]}. 

{mapping, "listener.ssl.$name.max_connections", "emqttd_server.listeners", [
                                                                  {default, {{max_connections}} },
                                                                  {commented, {{max_connections}} },
                                                                  {datatype, [integer, {atom, infinity}]},
                                                                  hidden
                                                                 ]}. 

{mapping, "listener.websocket.max_connections", "emqttd_server.listeners", [
                                                                  {default, {{max_connections}} },
                                                                  {commented, {{max_connections}} },
                                                                  {datatype, [integer, {atom, infinity}]},
                                                                  hidden
                                                                 ]}. 

{mapping, "listener.websocket.$name.max_connections", "emqttd_server.listeners", [
                                                                  {default, {{max_connections}} },
                                                                  {commented, {{max_connections}} },
                                                                  {datatype, [integer, {atom, infinity}]},
                                                                  hidden
                                                                 ]}. 
%% @doc listener.tcp.<name> is an IP address and TCP port that 
%% the broker will bind. You can define multiple listeners e.g:
%% - listener.tcp.default = 127.0.0.1:1883
%% - listener.tcp.internal = 127.0.0.1:10883
%% - listener.tcp.my_other_listener = 127.0.0.1:10884
%% This also works for SSL listeners and Websocket handlers:
%% - listener.ssl.default = 127.0.0.1:8883
%% - listener.websocket.default = 127.0.0.1:800 
{mapping, "listener.tcp.$name", "emqttd_server.listeners", [
                                                      {default, { "{{mqtt_default_ip}}", {{mqtt_default_port}} }},
                                                      {datatype, ip},
                                                      {include_default, "default"}
                                                     ]}.

{mapping, "listener.websocket.$name", "emqttd_server.listeners", [
                                                      {default, { "{{mqtt_default_ws_ip}}", {{mqtt_default_ws_port}} }},
                                                      {datatype, ip},
                                                      {include_default, "default"}
                                                     ]}.

{mapping, "listener.ssl.$name", "emqttd_server.listeners", [
                                                      {commented, { "{{mqtt_default_ip}}", {{mqtt_default_port}} }},
                                                      {datatype, ip},
                                                      {include_default, "default"}
                                                     ]}.

%% @doc Set the nr of acceptors waiting to concurrently accept new connections.
%% This can be specified either on the protocol level:
%%
%%     - listener.tcp.nr_of_acceptors
%%     - listener.ssl.nr_of_acceptors
%%     - listener.websocket.nr_of_acceptors 
%%
%% or on the listener level:
%%
%%     - listener.tcp.my_tcp_listener.nr_of_acceptors
%%     - listener.ssl.my_ssl_listener.nr_of_acceptors
%%     - listener.websocket.my_websocket_listener.nr_of_acceptors
{mapping, "listener.nr_of_acceptors", "emqttd_server.listeners", [
                                                                {default, 10},
                                                                {datatype, integer}
                                                              ]}.

{mapping, "listener.tcp.nr_of_acceptors", "emqttd_server.listeners", [
                                                                      {default, 10},
                                                                      {datatype, integer},
                                                                      hidden
                                                                 ]}. 

{mapping, "listener.tcp.$name.nr_of_acceptors", "emqttd_server.listeners", [
                                                                      {default, 10},
                                                                      {datatype, integer},
                                                                      {include_default, "default"},
                                                                      hidden
                                                                 ]}. 

{mapping, "listener.ssl.nr_of_acceptors", "emqttd_server.listeners", [
                                                                      {default, 10},
                                                                      {datatype, integer},
                                                                      hidden
                                                                 ]}. 

{mapping, "listener.ssl.$name.nr_of_acceptors", "emqttd_server.listeners", [
                                                                      {default, 10},
                                                                      {datatype, integer},
                                                                      {include_default, "default"},
                                                                      hidden
                                                                 ]}. 

{mapping, "listener.websocket.nr_of_acceptors", "emqttd_server.listeners", [
                                                                      {default, 10},
                                                                      {datatype, integer},
                                                                      hidden
                                                                 ]}. 

{mapping, "listener.websocket.$name.nr_of_acceptors", "emqttd_server.listeners", [
                                                                      {default, 10},
                                                                      {datatype, integer},
                                                                      {include_default, "default"},
                                                                      hidden
                                                                 ]}. 


%% @doc Set the mountpoint on the protocol level or on the listener level
%%
%%     - listener.tcp.mountpoint
%%     - listener.ssl.mountpoint
%%     - listener.websocket.mountpoint 
%%
%% or on the listener level:
%%
%%     - listener.tcp.my_tcp_listener.mountpoint
%%     - listener.ssl.my_ssl_listener.mountpoint
%%     - listener.websocket.my_ssl_listener.mountpoint
{mapping, "listener.mountpoint", "emqttd_server.listeners", [{default, "off"},
                                                             {datatype, string}
                                                            ]}. 
{mapping, "listener.tcp.mountpoint", "emqttd_server.listeners", [
                                                                 {datatype, string},
                                                                 hidden
                                                                ]}. 

{mapping, "listener.tcp.$name.mountpoint", "emqttd_server.listeners", [
                                                                       {datatype, string},
                                                                       {include_default, "default"},
                                                                       hidden
                                                                      ]}. 
{mapping, "listener.ssl.mountpoint", "emqttd_server.listeners", [
                                                                 {datatype, string},
                                                                 hidden
                                                                ]}. 

{mapping, "listener.ssl.$name.mountpoint", "emqttd_server.listeners", [
                                                                       {datatype, string},
                                                                       {include_default, "default"},
                                                                       hidden
                                                                      ]}. 
{mapping, "listener.websocket.mountpoint", "emqttd_server.listeners", [
                                                                       {datatype, string},
                                                                       hidden
                                                                      ]}. 

{mapping, "listener.websocket.$name.mountpoint", "emqttd_server.listeners", [
                                                                             {datatype, string},
                                                                             {include_default, "default"},
                                                                             hidden
                                                                            ]}. 

{translation, "emqttd_server.listeners", 
 fun(Conf) ->
         InfIntVal = fun(Val1) -> case Val1 of
                                  infinity -> infinity;
                                  Int when is_integer(Int) -> Int;
                                  _ -> cuttlefish:invalid("should be an integer")
                              end
                  end,
         MPVal = fun(Val2) -> case Val2 of
                                  "off" -> "";
                                  S when is_list(S) -> S;
                                  _ -> cuttlefish:invalid("should be a string")
                              end
                  end,

         F = fun(Prefix, Suffix, Validator) ->
                     Prefix2 = lists:flatten([Prefix, ".", Suffix]),
                     %% get default from root of the tree
                     Default1 = Validator(cuttlefish:conf_get(lists:flatten(["listener.", Suffix]), Conf)),
                     %% get the protocol specific default
                     Default2 = Validator(cuttlefish:conf_get(Prefix2, Conf, Default1)),
                     %% get the name value pairs
                     Prefix3 = lists:flatten([Prefix, ".$name"]),
                     [begin
                          Prefix4 = lists:flatten([Prefix, ".", Name, ".", Suffix]),
                          Val = Validator(cuttlefish:conf_get(Prefix4, Conf, Default2)),
                          {AddrPort, Val}
                      end 
                      || {[_, _, Name], AddrPort} <- lists:filter(
                                                            fun({K, _V}) ->
                                                                    cuttlefish_variable:is_fuzzy_match(K, string:tokens(Prefix3, "."))
                                                            end, Conf)]
             end,

         {TCPIPs, TCPMaxConns} = lists:unzip(F("listener.tcp", "max_connections", InfIntVal)),
         {SSLIPs, SSLMaxConns} = lists:unzip(F("listener.ssl", "max_connections", InfIntVal)),
         {WSIPs, WSMaxConns} = lists:unzip(F("listener.websocket", "max_connections", InfIntVal)),
         
         {TCPIPs, TCPNrOfAcceptors} = lists:unzip(F("listener.tcp", "nr_of_acceptors", InfIntVal)),
         {SSLIPs, SSLNrOfAcceptors} = lists:unzip(F("listener.ssl", "nr_of_acceptors", InfIntVal)),
         {WSIPs, WSNrOfAcceptors} = lists:unzip(F("listener.websocket", "nr_of_acceptors", InfIntVal)),

         {TCPIPs, TCPMountPoint} = lists:unzip(F("listener.tcp", "mountpoint", MPVal)),
         {SSLIPs, SSLMountPoint} = lists:unzip(F("listener.ssl", "mountpoint", MPVal)),
         {WSIPs, WSMountPoint} = lists:unzip(F("listener.websocket", "mountpoint", MPVal)),

         TCP = lists:zip(TCPIPs, lists:zip3(TCPMaxConns, TCPNrOfAcceptors, TCPMountPoint)),
         SSL = lists:zip(SSLIPs, lists:zip3(SSLMaxConns, SSLNrOfAcceptors, SSLMountPoint)),
         WEBSOCKET = lists:zip(WSIPs, lists:zip3(WSMaxConns, WSNrOfAcceptors, WSMountPoint)),

         {TCP, SSL, WEBSOCKET}
 end
}.

%% @doc Set the mountpoint on the protocol level or on the listener level
%%
%%     - listener.tcp.mountpoint
%%     - listener.ssl.mountpoint
%%     - listener.websocket.mountpoint 
%%
%% or on the listener level:
%%
%%     - listener.tcp.my_tcp_listener.mountpoint
%%     - listener.ssl.my_ssl_listener.mountpoint
%%     - listener.websocket.my_ssl_listener.mountpoint

{mapping, "bridge.tcp.$name", "emqttd_bridge.config", [
                                                       {default, {"127.0.0.1", 1889}},
                                                       {datatype, ip},
                                                       {include_default, "br0"},
                                                       {commented, "127.0.0.1:1889"}
                                                      ]}. 

{mapping, "bridge.tcp.$name.cleansession", "emqttd_bridge.config", [
                                                       {default, off},
                                                       {datatype, flag},
                                                       {include_default, "br0"},
                                                       {commented, off}
                                                      ]}. 

{mapping, "bridge.tcp.$name.client_id", "emqttd_bridge.config", [
                                                       {default, "auto"},
                                                       {datatype, string},
                                                       {include_default, "br0"},
                                                       {commented, "auto"}
                                                      ]}. 

{mapping, "bridge.tcp.$name.keepalive_interval", "emqttd_bridge.config", [
                                                       {default, 60},
                                                       {datatype, integer},
                                                       {include_default, "br0"},
                                                       {commented, 60}
                                                      ]}. 

{mapping, "bridge.tcp.$name.username", "emqttd_bridge.config", [
                                                       {datatype, string},
                                                       {include_default, "br0"},
                                                       {commented, "my_remote_user"}
                                                      ]}. 

{mapping, "bridge.tcp.$name.password", "emqttd_bridge.config", [
                                                       {datatype, string},
                                                       {include_default, "br0"},
                                                       {commented, "my_remote_password"}
                                                      ]}. 

{mapping, "bridge.tcp.$name.topic.$topic_id", "emqttd_bridge.config", [
                                                       {datatype, string},
                                                       {include_default, "1"}
                                                      ]}. 

{mapping, "bridge.tcp.$name.restart_timeout", "emqttd_bridge.config", [
                                                                       {datatype, integer},
                                                                       {default, 10},
                                                                       {include_default, "br0"},
                                                                       {commented, 10}
                                                                      ]}.

{mapping, "bridge.tcp.$name.try_private", "emqttd_bridge.config", [
                                                                       {datatype, flag},
                                                                       {default, on},
                                                                       {include_default, "br0"},
                                                                       {commented, on}
                                                                      ]}.

{mapping, "bridge.registry_mfa", "emqttd_bridge.registry_mfa", 
 [
  {default, "{emqttd_reg,direct_plugin_exports,[emqttd_bridge]}"},
  {datatype, string},
  hidden
 ]}. 

{translation, "emqttd_bridge.registry_mfa", 
 fun(Conf) ->
         S = cuttlefish:conf_get("bridge.registry_mfa", Conf),
         {ok, T, _} = erl_scan:string(S ++ "."),
         {ok, Term} = erl_parse:parse_term(T),
         Term
 end}.

{translation, "emqttd_bridge.config", 
 fun(Conf) ->
         BoolVal = fun(_, B) when is_boolean(B) -> B end,
         StringVal = fun(_, S) when is_list(S) -> S; 
                        (_, undefined) -> undefined end,
         IntVal = fun(_, I) when is_integer(I) -> I;
                     (_, undefined) -> undefined end,
         ClientIdVal = fun(Name, "auto") -> 
                               {ok, HostName} = inet:gethostname(),
                               lists:flatten([HostName, ".", Name]);
                          (_, L) when is_list(L) -> L
                       end,

         TopicVal = fun
                        (_, TopicString) when is_list(TopicString) ->
                            TTopicString = re:replace(TopicString, "\\*", "#", [{return, list}]),
                            Directions = ["out", "in", "both"],
                            QoSs = ["0", "1", "2"],
                            [Pattern|Rest0] = string:tokens(TTopicString, " "),
                            case Rest0 of
                                [MaybeDirection|Rest1] ->
                                    {Direction, Rest2} =
                                    case lists:member(MaybeDirection, Directions) of
                                        true -> 
                                            {list_to_atom(MaybeDirection), Rest1};
                                        false ->
                                            {out, Rest0}
                                    end,
                                    {QoS, Rest3} =
                                    case Rest2 of
                                        [] ->
                                            {0, []};
                                        [MaybeQoS|Rest4] ->
                                            case lists:member(MaybeQoS, QoSs) of
                                                true ->
                                                    {list_to_integer(MaybeQoS), Rest4};
                                                false ->
                                                    {0, Rest4}
                                            end
                                    end,
                                    case Rest3 of
                                        [] ->
                                            {Pattern, Direction, QoS, "", ""};
                                        [LocalPrefix, RemotePrefix] ->
                                            {Pattern, Direction, QoS, LocalPrefix, RemotePrefix};
                                        _ ->
                                            cuttlefish:invalid("should be a string of the form 'pattern [[[ out | in | both ] qos-level] local-prefix remote-prefix]'")
                                    end;
                                [] ->
                                    {Pattern, out, 0, "", ""}
                            end;
                        (_, _) ->
                            cuttlefish:invalid("should be a string of the form 'pattern [[[ out | in | both ] qos-level] local-prefix remote-prefix]'")
                    end,

         F = fun(Prefix, Suffix, Validator) ->
                     %% get the name value pairs
                     Prefix3 = lists:flatten([Prefix, ".$name"]),
                     [begin
                          case lists:prefix("topic", Suffix) of
                              true ->
                                  BrConfigs =
                                  [begin
                                       P = lists:flatten(
                                             [Prefix, ".", Name, ".topic.", integer_to_list(I)]
                                            ), 
                                       cuttlefish:conf_get(P, Conf, undefined)
                                   end || I <- lists:seq(1,100)],
                                  {AddrPort, [Validator(Name, C) || C <- BrConfigs, C /= undefined]};
                              false ->
                                  Prefix4 = lists:flatten([Prefix, ".", Name, ".", Suffix]),
                                  Val = Validator(Name, cuttlefish:conf_get(Prefix4, Conf, undefined)),
                                  {AddrPort, Val}
                          end
                      end 
                      || {[_, _, Name], AddrPort} <- lists:filter(
                                                            fun({K, _V}) ->
                                                                    cuttlefish_variable:is_fuzzy_match(K, string:tokens(Prefix3, "."))
                                                            end, Conf)]
             end,

         MZip = fun([H|_] = ListOfLists) ->
                        Size = length(H), %% get default size
                        ListOfLists = [L || L <- ListOfLists, length(L) == Size],
                        [list_to_tuple(
                           lists:reverse(
                             lists:foldl(
                               fun(L, Acc) ->
                                       [lists:nth(I, L)|Acc]
                               end, [], ListOfLists)))
                         || I <- lists:seq(1, Size)]
                end,

         {TCPIPs, TCPCleanSessions} = lists:unzip(F("bridge.tcp", "cleansession", BoolVal)),
         {TCPIPs, TCPClientIds} = lists:unzip(F("bridge.tcp", "client_id", ClientIdVal)),
         {TCPIPs, TCPKeepAlive} = lists:unzip(F("bridge.tcp", "keepalive_interval", IntVal)),
         {TCPIPs, TCPUserNames} = lists:unzip(F("bridge.tcp", "username", StringVal)),
         {TCPIPs, TCPPasswords} = lists:unzip(F("bridge.tcp", "password", StringVal)),
         {TCPIPs, TCPRestartTimeouts} = lists:unzip(F("bridge.tcp", "restart_timeout", IntVal)),
         {TCPIPs, TCPTryPrivates} = lists:unzip(F("bridge.tcp", "try_private", BoolVal)),
         {TCPIPs, TCPTopics} = lists:unzip(lists:usort(F("bridge.tcp", "topic", TopicVal))),
         TCP = lists:zip(TCPIPs, MZip([TCPCleanSessions, 
                                       TCPClientIds, 
                                       TCPKeepAlive, 
                                       TCPRestartTimeouts,
                                       TCPUserNames, 
                                       TCPPasswords,
                                       TCPTryPrivates,
                                       TCPTopics])), 
         {TCP, []}
 end
}.

%% @doc Set the path to an access control list file. 
{mapping, "acl_file", "emqttd_acl.file", [
                                          {default, "{{platform_etc_dir}}/emqttd.acl"},
                                          {datatype, file}
                                         ]}.

%% @doc Set the path to a password file. 
{mapping, "password_file", "emqttd_passwd.file", [
                                                  {default, "{{platform_etc_dir}}/emqttd.passwd"},
                                                  {datatype, file}
                                                 ]}.

%% @doc Allow anonymous users to connect, default is 'off'
{mapping, "allow_anonymous", "emqttd_passwd.allow_anonymous", [
                                                               {default, off},
                                                               {datatype, flag}
                                                              ]}.

%% @doc Set the max size for client ids, MQTT v3.1 specifies the
%% limit of 23 characterd
{mapping, "max_client_id_size", "emqttd_server.max_client_id_size", [
                                                               {default, 23},
                                                               {commented, 23},
                                                               {datatype, integer}
                                                              ]}.
%% @doc Set the time in seconds after a QoS=1 or QoS=2 message has been sent
%% that emqttd will wait before retrying when no response is received.
{mapping, "retry_interval", "emqttd_server.retry_interval", [
                                                             {default, 20},
                                                             {commented, 20},
                                                             {datatype, integer}
                                                            ]}.


{mapping, "table_definition_mod", "mnesia_cluster.table_definition_mod", [
                                                                          {default, "{emqttd_reg,emqttd_table_defs,[]}"},
                                                                          {datatype, string},
                                                                          hidden
                                                                         ]}. 

{mapping, "cluster_monitor_callbacks", "mnesia_cluster.cluster_monitor_callbacks", [
                                                                          {default, "[emqttd_cluster]"},
                                                                          {datatype, string},
                                                                          hidden
                                                                         ]}. 

{mapping, "app_process", "mnesia_cluster.app_process", [
                                                                          {default, emqttd_cluster},
                                                                          {datatype, atom},
                                                                          hidden
                                                                         ]}. 

{translation, "mnesia_cluster.table_definition_mod", 
 fun(Conf) ->
         S = cuttlefish:conf_get("table_definition_mod", Conf),
         {ok, T, _} = erl_scan:string(S ++ "."),
         {ok, Term} = erl_parse:parse_term(T),
         Term
 end}.

{translation, "mnesia_cluster.cluster_monitor_callbacks", 
 fun(Conf) ->
         S = cuttlefish:conf_get("cluster_monitor_callbacks", Conf),
         {ok, T, _} = erl_scan:string(S ++ "."),
         {ok, Term} = erl_parse:parse_term(T),
         Term
 end}.





%% @doc Where to emit the default log messages (typically at 'info'
%% severity):
%%      off: disabled
%%     file: the file specified by log.console.file
%%  console: to standard output (seen when using `emqttd attach-direct`)
%%     both: log.console.file and standard out.
{mapping, "log.console", "lager.handlers", [
                                            {default, {{console_log_default}} },
                                            {datatype, {enum, [off, file, console, both]}}
                                           ]}.
%% @doc The severity level of the console log, default is 'info'.
{mapping, "log.console.level", "lager.handlers", [
                                                  {default, info},
                                                  {datatype, {enum, [debug, info, warning, error]}}
                                                 ]}.
%% @doc When 'log.console' is set to 'file' or 'both', the file where
%% console messages will be logged.
{mapping, "log.console.file", "lager.handlers", [
                                                 {default, "{{platform_log_dir}}/console.log"},
                                                 {datatype, file}
                                                ]}.
%% @doc The file where error messages will be logged.
{mapping, "log.error.file", "lager.handlers", [
                                               {default, "{{platform_log_dir}}/error.log"},
                                               {datatype, file}
                                              ]}.
%% @doc When set to 'on', enables log output to syslog.
{mapping, "log.syslog", "lager.handlers", [
                                           {default, off},
                                           {datatype, flag}
                                          ]}.
{translation,
 "lager.handlers",
 fun(Conf) ->
         SyslogHandler = [{lager_syslog_backend, ["emqttd", daemon, info]} ||
                          cuttlefish:conf_get("log.syslog", Conf)],
         ErrorHandler = case cuttlefish:conf_get("log.error.file", Conf) of
                            undefined -> [];
                            ErrorFilename -> [{lager_file_backend, [{file, ErrorFilename},
                                                                    {level, error},
                                                                    {size, 10485760},
                                                                    {date, "$D0"},
                                                                    {count, 5}]}]
                        end,
         ConsoleLogLevel = cuttlefish:conf_get("log.console.level", Conf),
         ConsoleLogFile = cuttlefish:conf_get("log.console.file", Conf),
         ConsoleHandler = {lager_console_backend, ConsoleLogLevel},
         ConsoleFileHandler = {lager_file_backend, [{file, ConsoleLogFile},
                                                    {level, ConsoleLogLevel},
                                                    {size, 10485760},
                                                    {date, "$D0"},
                                                    {count, 5}]},
         ConsoleHandlers = case cuttlefish:conf_get("log.console", Conf) of
                               off -> [];
                               file -> [ConsoleFileHandler];
                               console -> [ConsoleHandler];
                               both -> [ConsoleHandler, ConsoleFileHandler];
                               _ -> []
                           end,
         SyslogHandler ++ ConsoleHandlers ++ ErrorHandler
 end
}.
%% @doc Whether to enable Erlang's built-in error logger.
{mapping, "sasl", "sasl.sasl_error_logger", [
                                             {default, off},
                                             {datatype, flag},
                                             hidden
                                            ]}.
%% @doc Whether to enable the crash log.
{mapping, "log.crash", "lager.crash_log", [
                                           {default, on},
                                           {datatype, flag}
                                          ]}.
%% @doc If the crash log is enabled, the file where its messages will
%% be written.
{mapping, "log.crash.file", "lager.crash_log", [
                                                {default, "{{platform_log_dir}}/crash.log"},
                                                {datatype, file}
                                               ]}.
{translation,
 "lager.crash_log",
 fun(Conf) ->
         case cuttlefish:conf_get("log.crash", Conf) of
             false -> undefined;
             _ ->
                 cuttlefish:conf_get("log.crash.file", Conf, "{{platform_log_dir}}/crash.log")
         end
 end}.
%% @doc Maximum size in bytes of individual messages in the crash log
{mapping, "log.crash.maximum_message_size", "lager.crash_log_msg_size", [
                                                                         {default, "64KB"},
                                                                         {datatype, bytesize}
                                                                        ]}.
%% @doc Maximum size of the crash log in bytes, before it is rotated
{mapping, "log.crash.size", "lager.crash_log_size", [
                                                     {default, "10MB"},
                                                     {datatype, bytesize}
                                                    ]}.
%% @doc The schedule on which to rotate the crash log. For more
%% information see:
%% https://github.com/basho/lager/blob/master/README.md#internal-log-rotation
{mapping, "log.crash.rotation", "lager.crash_log_date", [
                                                         {default, "$D0"}
                                                        ]}.
%% @doc The number of rotated crash logs to keep. When set to
%% 'current', only the current open log file is kept.
{mapping, "log.crash.rotation.keep", "lager.crash_log_count", [
                                                               {default, 5},
                                                               {datatype, [integer, {atom, current}]},
                                                               {validators, ["rotation_count"]}
                                                              ]}.
{validator,
 "rotation_count",
 "must be 'current' or a positive integer",
 fun(current) -> true;
    (Int) when is_integer(Int) andalso Int >= 0 -> true;
    (_) -> false
 end}.
{translation,
 "lager.crash_log_count",
 fun(Conf) ->
         case cuttlefish:conf_get("log.crash.rotation.keep", Conf) of
             current -> 0;
             Int -> Int
         end
 end}.
%% @doc Whether to redirect error_logger messages into lager -
%% defaults to true
{mapping, "log.error.redirect", "lager.error_logger_redirect", [
                                                                {default, on},
                                                                {datatype, flag},
                                                                hidden
                                                               ]}.
%% @doc Maximum number of error_logger messages to handle in a second
{mapping, "log.error.messages_per_second", "lager.error_logger_hwm", [
                                                                      {default, 100},
                                                                      {datatype, integer},
                                                                      hidden
                                                                     ]}.
%% @doc Cookie for distributed node communication. All nodes in the
%% same cluster should use the same cookie or they will not be able to
%% communicate.
{mapping, "distributed_cookie", "vm_args.-setcookie", [
                                                       {default, "emqttd"}
                                                      ]}.
%% override zdbbl from 1mb to 32mb
{mapping, "erlang.distribution_buffer_size", "vm_args.+zdbbl", [
                                                                {default, "32MB"},
                                                                merge
                                                               ]}.
